<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SRS</title>
</head>


<body>

<div><h1>Software Requirements Specification (SRS)</h1>
    <p><h1> <strong>For</strong> </h1></p>

    <p><h1>Project Name here</h1></p> <br>

    <p> <strong> Version 1.0 Approved </strong> </p> <br>
    <p> <strong> Prepared by ... </strong> </p> <br>
    <p> <strong> Organization ... </strong> </p> <br>
    <p> <strong> Date Created ... </strong> </p> <br>


    <p>The IEEE has a different standard for a "Software Requirements
    Document" (SRD), which is IEEE/EAI 12207.1-1997.  If you look in the table
    at the back of IEEE Std 830-1998 you will see the cross reference
    tables in Appendix B, showing that these are consistent with one another.</p>

    <p>Standards are periodically updated, so there are several
        versions of IEE STd 830, including IEEE Std 830-1983, -1993, and
        -1998.  These standards also allow some room for discretion.
        It therefore follows that you may see several different suggested
        table of contents outlines for SRS documents purporting to
        be based on this standard.</p>

</div>
<br><br><br>

<div><h1>Table of Contents</h1>


<pre><strong> 1. Introduction</strong>
      1.1 Purpose
      1.2 Document Conventions
      1.3 Intended Audience and Reading Suggestions
      1.4 Product Scope
      1.5 References
<strong> 2. Overall Description</strong>
      2.1 Product Perspective
      2.2 Product Functions
      2.3 User Classes and Characteristics
      2.4 Operating Environment
      2.5 Design and Implementation Constraints
      2.6 User Documentation 
      2.7 Assumptions and Dependencies 

<strong> 3. Introduction</strong>
      3.1 User Interfaces 
      3.2 Hardware Interfaces 
      3.3 Software Interfaces 
      3.4 Communications Interfaces
<strong> 4. Introduction</strong>
      4.1 System Feature 1
      4.2 System Feature 2 (and so on)
<strong> 5. Introduction</strong>
      5.1 Performance Requirements
      5.3 Security Requirements
      5.4 Software Quality Attributes 
      5.5 Business Rules      
<strong> 6. Other requirements</strong>
<strong> Appendix A: Glossary</strong>
<strong> Appendix B: Analysis Models</strong>
<strong> Appendix C: To Be Determined List</strong>
</pre>


<br>
<br>
<br>
<div><h1>Revision History</h1>

    <table border="">
        <tbody>
            <tr>    <th>Name</th><th>Date</th><th>Reasons for Changes</th><th>Version</th>
            </tr>

            <tr>
                <td>None</td><td>None</td><td>None</td><td>None</td>
            </tr>
            <tr>
                <td>None</td><td>None</td><td>None</td><td>None</td>
            </tr>

        </tbody>
    </table>
</div>
<br>
<br>
<br>



<h1>1. Introduction</h1>

<div>
    <h2>1.1 Purpose</h2>
    <p>The purpose of this document is to present a detailed description of the Web Searching Service 
        Application. It will describe the application's purpose and features that the project will cover. 
        It will further elaborate the system constraints, interface and its interactions with other applications.
        
    </p>
    </div><br>

<div>
    <h2>1.2 Document Conventions</h2>
    <p>Describe any standards or typographical conventions that were followed when writing this SRS, 
        such as fonts or highlighting that have special significance. For example, state whether priorities 
        for higher-level requirements are assumed to be inherited by detailed requirements, or whether 
        every requirement statement is to have its own priority.</p>
</div><br>

<div>
    <h2>1.3 Intended Audience and Reading Suggestions</h2>
    <p>This document allows users: 
        •	To navigate through the application, and its various functionalities.
        •	Familiarize the user with the user interface.
        •	Detailed description of the create, view, search and delete operations.
        •	Implement new crawling strategies.
        •	To learn about product flexibility and crawling strategies.
        
        Allows developers:
        •	To understand the nature and extent of the current version of the application
        •	Provides a detailed overview of the application features and functions
        •	To help improve and build on existing features
        •	Fix, test and debug existing features 
        
        Allows marketing managers:
        •	To understand and target potential users on the market
        •	Advertise product features across different platforms
        
        *Users are suggested to read section 1.1, 2.2, 3.1, 3.3, 4.1 and 4.2
        </p>
</div><br>

<div>
    <h2>1.4 Product Scope</h2>
    <p>Snippet is a cross platform web crawling and scrapping application that allows users to source and save specific text information about their topic of interest in the form of a cluster, which is essentially is a list of saved text files after a webpage is crawled for certain information. The application is cross platform, versatile and can be used for a multitude of search and list activities, ideal for research work, data sourcing, collecting text resources etc. It will allow users to extract extensive information across multiple URL’s with just a click of a button, save it and access it anytime, anywhere. The in-depth search feature can dig through URLs within URLs to maximize the output of a search result making the process as swift and easy as possible. With such a powerful tool at hand, research and data sourcing will be easier than ever before.</p>
</div><br>

<div>
    <h2>1.5 References</h2>
    <p>List any other documents or Web addresses to which this SRS refers. These may include user 
        interface style guides, contracts, standards, system requirements specifications, use case 
        documents, or a vision and scope document. Provide enough information so that the reader could 
        access a copy of each reference, including title, author, version number, date, and source or 
        location.</p>
</div><br>

<br><br>




<h1>2. Overall Description</h1>

<div>
    <h2>2.1 Product Perspective</h2>
    <p>Snippet simply is a web crawler that browses a URL to condense and display its contents in a way that is most effective and informative to the user. The idea is to make text data extraction efficient, fast and thorough as it makes research and data sourcing a lot easier, all the user has to provide is the link to crawl and the depth to which it is to be crawled. The system will distill the related documents in the form of a cluster which the user can save or revisit according to their liking. Search strategies can also be customized by the user where they can specify the type of data to extract from the URLs (only text documents in this case). In a world experiencing information explosion, harvesting data out of the internet pool is becoming less feasible every second; that is where Snippet comes in. Data mining, analyzing market demand, monitoring competitor prices are few of the many advantages of using Snippet. A tool powerful enough to extract targeted data rapidly and efficiently. </p>
</div><br>

<div>
    <h2>2.2 Product Functions</h2>
    <p>A Snippet Account user can do the following:

        1.	Crawl URLs
        
        •	Users can provide one or multiple URLs to be crawled simultaneously.
        •	They can specify the type of text documents they want to extract.
        •	Crawling depth must be specified to crawl links successfully.
        
        2.	Create Cluster
        
        •	Clusters can be named and saved to be accessed at all times.
        •	View saved clusters and its details.
        •	Existing clusters can be searched, deleted, modified etc.
        •	Export search results.
        
        </p>
</div><br>

<div>
    <h2>2.3 User Classes and Characteristics</h2>
    <p>Snippet has an extensively diverse user class considering it can help businesses with their market research and be at the top of their game, and it can also help a college students obtain data for their machine learning project. Anyone can crawl the web for text documents for research, data analysis, data extraction, monitoring market prices etc. </p>
</div><br>

<div>
    <h2>2.4 Operating Environment</h2>
    <p>•	Database: Postgre SQL
        •	Operating System: Windows, IOS, Android
        •	Web Server
        •	Software framework: Django
        </p>
</div><br>

<div>
    <h2>2.5 Design and Implementation Constraints</h2>
    <p>•	User information is required to sign up into the system therefore a database is used which the website can access and store user details.
        •	Postgre SQL server is used as SQL engine and database
        •	Users can access their Snippet account from and computer with a browser and an internet connection.
        •	User must enter their username and password correctly to be able to access their account.
        •	User must enter depth of crawling limit to make a search cluster.
        •	User must select a search strategy to create a cluster.
        •	User can only extract text documents from the system.
        </p>
</div><br>

<div>
    <h2>2.6 User Documentation</h2>
    <p>Not Applicable</p>
</div><br>

<div>
    <h2>2.7 Assumptions and Dependencies</h2>
    <p>Assuming the device runs on a Microsoft or MacOS, Snippet should be able to export cluster data. The product needs third party applications such as Postgre SQL as a database, REST APIs to help the interfaces work cohesively, Django as a framework and A web browser to access the internet. </p>
</div><br>

<br><br>





<h1>3.  External Interface Requirements</h1>

<div>
    <h2>3.1 User Interfaces</h2>
    <p>Describe the logical characteristics of each interface between the software product and the users. 
        This may include sample screen images, any GUI standards or product family style guides that are 
        to be followed, screen layout constraints, standard buttons and functions (e.g., help) that will 
        appear on every screen, keyboard shortcuts, error message display standards, and so on. Define 
        the software components for which a user interface is needed. Details of the user interface design 
        should be documented in a separate user interface specification.</p>
    </div><br>

<div>
    <h2>3.2 Hardware Interfaces</h2>
    <p>Describe the logical and physical characteristics of each interface between the software product 
        and the hardware components of the system. This may include the supported device types, the 
        nature of the data and control interactions between the software and the hardware, and 
        communication protocols to be used.</p>
</div><br>

<div>
    <h2>3.3 Software Interfaces</h2>
    <p>Describe the connections between this product and other specific software components (name 
        and version), including databases, operating systems, tools, libraries, and integrated commercial 
        components. Identify the data items or messages coming into the system and going out and 
        describe the purpose of each. Describe the services needed and the nature of communications. 
        Refer to documents that describe detailed application programming interface protocols. Identify 
        data that will be shared across software components. If the data sharing mechanism must be 
        implemented in a specific way (for example, use of a global data area in a multitasking operating 
        system), specify this as an implementation constraint.</p>
</div><br>

<div>
    <h2>3.4 Communications Interfaces</h2>
    <p>Describe the requirements associated with any communications functions required by this 
        product, including e-mail, web browser, network server communications protocols, electronic 
        forms, and so on. Define any pertinent message formatting. Identify any communication standards 
        that will be used, such as FTP or HTTP. Specify any communication security or encryption issues, 
        data transfer rates, and synchronization mechanisms.</p>
</div><br>

<br><br>





<h1>4. System Features</h1>

<p>This template illustrates organizing the functional requirements for the product by system 
    features, the major services provided by the product. You may prefer to organize this section by 
    use case, mode of operation, user class, object class, functional hierarchy, or combinations of 
    these, whatever makes the most logical sense for your product.
</p>

<div>
<h2>4.1 System Feature 1</h2>
    <h3>4.1.1 Description and Priority</h3>
    <p>Provide a short description of the feature and indicate whether it is of High, Medium, or 
        Low priority. You could also include specific priority component ratings, such as 
        benefit, penalty, cost, and risk (each rated on a relative scale from a low of 1 to a 
        high of 9).</p>
    
    <h3>4.1.2  Stimulus/Response Sequences</h3>
    <p>List the sequences of user actions and system responses that stimulate the behavior 
        defined for this feature. These will correspond to the dialog elements associated with 
        use cases.</p>
</div><br>

<div>
    <h2>4.2 and so on...</h2>
    <p>...</p>
</div><br>

<br><br>





<h1>5. Other Nonfunctional Requirements</h1>

<div>
    <h2>5.1 Performance Requirements</h2>
    <p>The application performance is optimized to search results as quickly and efficiently as possible and display the data comprehensively. Interacting with the interface will be easy and uninterrupted. System will be able to handle large amounts of data and backup the results in the database. </p>
</div><br>

<div>
    <h2>5.2 Safety Requirements</h2>
    <p>Using a secure database to ensure safety of user information is necessary. Crawling sites that are off limits must be maintained. </p>
</div><br>

<div>
    <h2>5.3 Security Requirements</h2>
    <p>Users details must be stored in a secure database and will only be able to modify their own personal details. Users will have access constraints so that the database cannot be accessed.</p>
</div><br>

<div>
    <h2>5.4 Software Quality Attributes</h2>
    <p>Specify any additional quality characteristics for the product that will be important to either the 
        customers or the developers. Some to consider are: adaptability, availability, correctness, flexibility, 
        interoperability, maintainability, portability, reliability, reusability, robustness, testability, and 
        usability. Write these to be specific, quantitative, and verifiable when possible. At the least, clarify 
        the relative preferences for various attributes, such as ease of use over ease of learning.</p>
</div><br>

<div>
    <h2>5.5 Business Rules</h2>
    <p>List any operating principles about the product, such as which individuals or roles can perform 
        which functions under specific circumstances. These are not functional requirements in 
        themselves, but they may imply certain functional requirements to enforce the rules.</p>
</div><br>

<br><br>




<h1>6. Other requirements</h1>
<p>TBD</p>
<br>


<h1>Appendix A: Glossary</h1>
<p>TBD</p>
<br>


<h1>Appendix B: Analysis Models</h1>
<p>Optionally, include any pertinent analysis models, such as data flow diagrams, class diagrams, 
    state-transition diagrams, or entity-relationship diagrams.</p>
<br>


<h1>Appendix C: To Be Determined List</h1>
<p>•	Other Requirements
   •	Glossary
</p>



</body>
</html>